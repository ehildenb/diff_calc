---(

An fmod is one of the basic building blocks in Maude. Here we're declaring an
fmod called `CALCULUS` it imports ("protects") various other modules

-   BOOL: This gives us access to the `if_then_else_fi` used in the definition
    of derivatives of variables

-   RAT: This gives us access to rational numbers

-   QID: This gives us access to "quoted identifiers", but instead of calling
    them a "Qid", I want to call them a "Var". So I want to have variables in my
    formulas (as you often want when doing calculus), but want to use the
    existing machinary of Qid instead of hand-rolling my own.

)---

fmod CALCULUS is
    protecting BOOL .
    protecting RAT .
    protecting QID * ( sort Qid to Var ) .

    ---(
    Here I am saying that there are two new things (sorts == types) that exist,
    which are `Const` (for constants), and `Func` (for functions). I also say
    that any `Rat` (rational number) is also a `Const`, and that any `Const` is
    also a `Func`.  I also say that any `Var` is a `Func`. And I declare a new
    sort `Subst` for later.
    )---

    sorts Const Func .
    subsorts Rat < Const < Func .
    subsort Var < Func .
    sort Subst .

    ---(
    A couple of useful constants are declared here. I want to be able to use
    `pi` and `e` in my formulae.
    )---

    ops pi e : -> Const [ctor] .

    ---(
    I want to be able to add, subtract, multiply, negate, and power my formulas.
    I also want to be able to take the cos, sin, or ln of them.
    )---

    op -_  : Func -> Func [ctor ditto] .
    op _-_ : Func Func -> Func [ditto] .
    op _+_ : Func Func -> Func [ctor ditto] .
    op _*_ : Func Func -> Func [ctor ditto] .
    op _/_ : Func Func -> Func [ctor ditto] .
    op _^_ : Func Func -> Func [ctor ditto] .
    ops cos sin ln : Func -> Func [ctor] .

    vars N M   : Rat .
    vars X Y   : Var .
    vars C D   : Const .
    vars F G H : Func .
    vars F' G' : Func .
    var S      : Subst .

    ---(
    I need to declare some identities (can think of them as axioms) which are
    true about the things I've built. Look at each of the equations below and
    ask yourself if they are true.
    )---

    --- various identities
    eq 0 * F     = 0 .
    eq 1 * F     = F .
    eq 0 + F     = F .
    eq F - G     = F + (- G) .
    eq F + (- F) = 0 .
    eq F ^ 0     = 1 .
    eq F ^ 1     = F .
    eq 1 ^ F     = 1 .

    eq - (- F)   = F .
    eq - (N * F) = (- N) * F .
    eq F * - G   = - (F * G) .

    eq (N * F) / G = N * (F / G) .
    eq F / (N * G) = (F / G) / N .
    ceq F / N      = (1 / N) * F if not (F :: Const) .

    eq (F ^ G) * (F ^ H) = F ^ (G + H) .
    eq (F ^ G) / (F ^ H) = F ^ (G - H) .
    eq F ^ (- G)         = 1 / (F ^ G) .
    eq (F ^ G) ^ H       = F ^ (G * H) .

    eq sin(0)       = 0 .
    eq sin(pi)      = 0 .
    eq sin(pi / 2)  = 1 .
    eq sin(- F)     = - sin(F) .
    eq cos(0)       = 1 .
    eq cos(pi)      = -1 .
    eq cos(pi / 2)  = 0 .
    eq cos(- F)     = cos(F) .
    ceq sin(N * pi) = sin((N rem 2) * pi) if abs(N) > 2 .
    ceq cos(N * pi) = cos((N rem 2) * pi) if abs(N) > 2 .

    eq ln(e)     = 1 .
    eq ln(1)     = 0 .
    eq ln(e ^ F) = F .

    ---(
    Now we will use the Subst I declared earlier. Say we want to evaluate a
    function at some point? Let's say it's the function

    'x + ('y ^ 3)

    and we want to evaluate it at the point 'x := 5. We would say

    ('x + ('y ^ 3)) ['x := 5]

    These equations will go through and find all the 'x and replace them with 3.
    )---

    op _:=_ : Var Func -> Subst [ctor] .
    op _[_] : Func Subst -> Func [prec 80] .
    ----------------------------------------
    eq X [Y := F]    = if X == Y then F else X fi .
    eq C [S]         = C .
    eq (- F) [S]     = - (F [S]) .
    eq (F + G) [S]   = (F [S]) + (G [S]) .
    eq (F * G) [S]   = (F [S]) * (G [S]) .
    eq (F / G) [S]   = (F [S]) / (G [S]) .
    eq (F ^ G) [S]   = (F [S]) ^ (G [S]) .
    eq sin(F) [S]    = sin(F [S]) .
    eq cos(F) [S]    = cos(F [S]) .
    eq ln(F) [S]     = ln(F [S]) .

    ---(
    Now we want to be able to take (symbolic) derivatives of functions. That
    would be super cool! How do we do it? By defining the math! Suppose our
    function is once again `'x + ('y ^ 3)`, and we want to take the derivative
    with respect to `'x`. We would say
    `d/d 'x ('x + ('y ^ 3))`

    Are all these derivative rules correct?
    )---

    op d/d__ : Var Func -> Func .
    -----------------------------
    eq d/d X C       = 0 .
    eq d/d X Y       = if X == Y then 1 else 0 fi .

    eq d/d X (- F)   = - (d/d X F) .
    eq d/d X (F + G) = (d/d X F) + (d/d X G) .
    eq d/d X (F * G) = ((d/d X F) * G) + (F * (d/d X G)) .
    eq d/d X (F / G) = (((d/d X F) * G) - (F * (d/d X G))) / (G ^ 2) .

    eq d/d X (F ^ N) = N * (F ^ (N - 1)) * (d/d X F) .
    eq d/d X (e ^ F) = (e ^ F) * (d/d X F) .
    eq d/d X (F ^ G) = d/d X (e ^ (G * ln(F))) [owise] .

    eq d/d X sin(F)  = cos(F) * (d/d X F) .
    eq d/d X cos(F)  = (- sin(F)) * (d/d X F) .

    eq d/d X ln(F)   = (1 / F) * (d/d X F) .

    ---(
    Perhaps there are some functions we would like to be defined for us. The
    Gaussian would be one example. We can supply just the mean and std-dev and
    it should create the Gaussian for us (we also must supply the variable the
    Gaussian is over).
    )---

    op gauss : Var Rat Rat -> Func .
    --------------------------------
    eq gauss(X,N,M) = e ^ (- ((X - N) ^ 2) / (2 * (M ^ 2))) .

endfm

---(
Here are some examples that will immediately run on calling
`maude calculus.maude`

The first are some examples of evaluations, the rest of are examples of
differentiation.
)---

reduce ('x + ('y ^ 3)) ['x := 5] .
reduce ('x + ('y ^ 3)) ['y := 7] .
reduce ('x + ('y ^ 3)) ['y := 7] ['x := 5] .
reduce ln(e ^ 0) .
reduce gauss('x, 3, 5) ['x := 3] .

reduce d/d 'x ('x + 'y) .
reduce d/d 'x ('x + ('x ^ 3)) .
reduce d/d 'x (d/d 'y (cos ('x + 'y))) .
reduce d/d 'x (e ^ (('x - 'y) ^ 2)) .
reduce d/d 'x (ln ('x ^ 3)) .
reduce d/d 'x (cos('x) ^ sin('x + ('y ^ 3))) .

reduce (d/d 'x (gauss('x, 3, 5))) .
reduce (d/d 'x (gauss('x, 3, 5))) ['x := 3] .
reduce (d/d 'x (gauss('x, 3, 5))) ['x := (3 + 5)] .
